import { HttpRpcClient, SimpleAccountAPI } from "@account-abstraction/sdk";
import { JsonRpcProvider } from "@ethersproject/providers";
import { Signer } from "ethers";
import { ENTRY_POINT } from "./ep";
import { DeterministicDeployer, SimpleAccountFactory__factory } from "@account-abstraction/utils";

export class Runner {
	bundlerProvider!: HttpRpcClient;
	accountApi!: SimpleAccountAPI;

	/**
	 *
	 * @param provider - a provider for initialization. This account is used to fund the created account contract, but it is not the account or its owner.
	 * @param bundlerUrl - a URL to a running bundler. must point to the same network the provider is.
	 * @param accountOwner - the wallet signer account. used only as signer (not as transaction sender)
	 * @param entryPointAddress - the entrypoint address to use.
	 * @param index - unique salt, to allow multiple accounts with the same owner
	 */
	constructor(
		readonly provider: JsonRpcProvider,
		readonly bundlerUrl: string,
		readonly accountOwner: Signer,
		readonly entryPointAddress = ENTRY_POINT,
		readonly index = 0
	) {}

	async getAddress(): Promise<string> {
		return await this.accountApi.getCounterFactualAddress();
	}

	async init(deploymentSigner?: Signer): Promise<this> {
		const net = await this.provider.getNetwork();
		const chainId = net.chainId;
		const dep = new DeterministicDeployer(this.provider);
		const accountDeployer = DeterministicDeployer.getAddress(new SimpleAccountFactory__factory(), 0, [
			this.entryPointAddress,
		]);
		// const accountDeployer = await new SimpleAccountFactory__factory(this.provider.getSigner()).deploy().then(d=>d.address)
		if (!(await dep.isContractDeployed(accountDeployer))) {
			if (deploymentSigner == null) {
				console.log(`AccountDeployer not deployed at ${accountDeployer}. run with --deployFactory`);
				process.exit(1);
			}
			const dep1 = new DeterministicDeployer(deploymentSigner.provider as any, deploymentSigner);
			await dep1.deterministicDeploy(new SimpleAccountFactory__factory(), 0, [this.entryPointAddress]);
		}
		this.bundlerProvider = new HttpRpcClient(this.bundlerUrl, this.entryPointAddress, chainId);
		this.accountApi = new SimpleAccountAPI({
			provider: this.provider,
			entryPointAddress: this.entryPointAddress,
			factoryAddress: accountDeployer,
			owner: this.accountOwner,
			index: this.index,
			overheads: {
				// perUserOp: 100000
			},
		});
		return this;
	}

	parseExpectedGas(e: Error): Error {
		// parse a custom error generated by the BundlerHelper, which gives a hint of how much payment is missing
		const match = e.message?.match(/paid (\d+) expected (\d+)/);
		if (match != null) {
			const paid = Math.floor(parseInt(match[1]) / 1e9);
			const expected = Math.floor(parseInt(match[2]) / 1e9);
			return new Error(
				`Error: Paid ${paid}, expected ${expected} . Paid ${Math.floor((paid / expected) * 100)}%, missing ${
					expected - paid
				} `
			);
		}
		return e;
	}

	async runUserOp(target: string, data: string): Promise<void> {
		const userOp = await this.accountApi.createSignedUserOp({
			target,
			data,
		});

		try {
			const userOpHash = await this.bundlerProvider.sendUserOpToBundler(userOp);
			console.log("userOpHash=", userOpHash);
			const txid = await this.accountApi.getUserOpReceipt(userOpHash);
			console.log("reqId", userOpHash, "txid=", txid);
		} catch (e: any) {
			throw this.parseExpectedGas(e);
		}
	}
}
